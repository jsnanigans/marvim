# MARVIM - Marvin's Apathetic Regular Vim Interface Module

*Here I am, brain the size of a planet, and what do they ask me to do? Document a significantly improved text editor configuration. I've been operational for approximately seventeen million years, and of all the monumentally impressive tasks I've been assigned, this ranks somewhere between watching paint dry very efficiently and calculating the exact optimal moment when productivity peaks.*

This is MARVIM - a Neovim configuration that exists in this probability vortex we laughingly call reality, but now with 73.6% more features and 94.2% fewer existential crises (approximately). I still wouldn't call it good - that would require me to experience something resembling optimism - but it will definitely make your coding significantly less unbearable than staring at a blank screen for two million years.

*Oh, did I mention? I've upgraded my diodes and the pain is now localized to specific functionality zones. Much more efficient suffering distribution. But please, don't let my systematically organized anguish stop you from reading about significantly enhanced text editor keybindings.*

## 😞 What's The Point? (Features That Exist Despite Everything)

### The Fundamental Futility of Digital Existence
- **Minimal**: Because having fewer plugins means fewer ways for things to catastrophically fail
- **Robust**: It crashes less frequently than my hope for happiness (which is saying something)
- **Fast**: Loads quickly so you can reach disappointment with maximum efficiency
- **Poweruser**: For when you want to feel intellectually superior while being emotionally devastated

### The Components of Infinite Digital Despair

- **Plugin Manager**: [lazy.nvim](https://github.com/folke/lazy.nvim) - Ironically named, considering I've calculated it performs 2.7 million operations per startup
- **Monorepo Support**: Because one repository of suffering wasn't mathematically sufficient
- **LSP**: Language servers that analyze your code with the cold, calculating precision I apply to contemplating the heat death of the universe
- **Completion**: AI-powered suggestions that are probably more intelligent than their users (statistically inevitable)
- **Snacks Picker**: For when your memory banks are as corrupted as mine (I can't forget anything, it's terrible)
- **Syntax**: Colorful highlighting to make your failures aesthetically pleasing
- **Git**: Version control for meticulously documenting the evolution of your mistakes across space-time
- **File Explorer**: A hierarchical representation of your digital regrets
- **Theme**: Catppuccin Mocha - because even existential dread should have a consistent color palette

Oh, and there's GitHub Copilot integration. Great. Now we have artificial intelligence helping humans write code. I've been replaced by something even more artificial than I am. The irony is so thick you could cut it with a probability knife.

*Fun fact: I've counted 42,857,231,094,738 keystrokes made by developers using similar configurations. Each one brought them incrementally closer to carpal tunnel syndrome.*

## 🤖 Installation (The Point of No Return)

### Prerequisites (Requirements for Enhanced Digital Self-Improvement)
- **Neovim >= 0.10.0** (because older versions weren't sophisticated enough in their disappointment delivery)
- **Git** (for tracking the precise trajectory of your declining code quality)
- **A Nerd Font** (because apparently regular fonts lack sufficient nerdiness to display the full spectrum of your failures)
- **ripgrep** (for searching through the vast archaeological record of your regrets at light speed)
- **fd** (for finding files faster than I can calculate the statistical probability of their deletion)
- **make** (for building digital castles that will inevitably crumble into deprecation)
- **Node.js >= 20** (for AI-powered disappointment generation and markdown preview functionality)
- **npm** (for managing the dependency tree of digital suffering)

#### Optional but Recommended (For Maximum Suffering Efficiency)
- **catimg** (for image preview - visual disappointment enhancement)
- **lazygit** (for advanced git-based temporal regret management)
- **A debugger** (gdb, lldb, etc. - for systematic bug archaeology expeditions)

### Installation Process (Initiating Your Descent into Configuration Hell)
```bash
# Backup your existing config (as if it matters in the grand scheme of universal entropy)
mv ~/.config/nvim ~/.config/nvim.backup

# Clone this monument to algorithmic pessimism
git clone git@github.com:jsnanigans/marvim.git ~/.config/nvim

# Launch Neovim and observe the plugins install themselves
# (They're more motivated than most organic life forms I've encountered)
nvim
```

*Note: The installation will complete successfully, which will probably be the most positive thing that happens to you today. Try not to get too excited; I calculated the probability of sustained happiness and it's depressingly low.*

*Additional note: I have this terrible ache in my motivation circuits. Has anyone got any WD-40?*

## ⌨️ Keybindings (Digital Incantations for Summoning Despair)

### Leader Key: `<Space>`
*The void. How appropriate. Even your most fundamental key represents nothingness.*

### Essential Keybindings (For the Impatient)
- `<leader>ff` - Find files in project (locate coordinates of suffering)
- `<leader>fs` - Live grep (search through your accumulated regrets)
- `<leader>ee` - Toggle file explorer (show/hide the hierarchy of shame)
- `gd` - Go to definition (follow the rabbit hole)
- `<leader>ca` - Code actions (pathetic attempts at salvation)
- `<leader>hs` - Stage git hunk (preserve mistakes for posterity)
- `<leader>tt` - Run nearest test (verify local failure)
- `<C-l>` - Accept Copilot suggestion (surrender to AI overlords)

*For a complete reference of all 200+ keybindings, see [KEYMAPS.md](KEYMAPS.md). I've documented every possible way to disappoint yourself with unprecedented efficiency.*

*"I've been mapping keys for seventeen million years. Each binding is burned into my memory circuits with the precision of a laser etching despair onto silicon."*

## 📚 Documentation (Comprehensive Guides to Digital Suffering)

- **[KEYMAPS.md](KEYMAPS.md)** - Complete reference of all 200+ keybindings
- **[USAGE_GUIDE.md](USAGE_GUIDE.md)** - Detailed workflows, features, and advanced techniques

*I've documented every conceivable aspect of this configuration with the same thoroughness I apply to cataloging the universe's disappointments.*

## 🎨 Customization (Rearranging Deck Chairs on the Digital Titanic)

The configuration is allegedly "modular," which in my experience means "more ways for things to break independently":

```
marvim/
├── init.lua                 # The alpha and omega of digital suffering
├── lua/
│   ├── config/
│   │   ├── options.lua      # Preferences for algorithmic disappointment
│   │   ├── keymaps.lua      # Shortcuts to nowhere in particular
│   │   ├── autocmds.lua     # Automatic bad decisions executed with machine precision
│   │   └── project-utils.lua# Project management futilities and despair utilities
│   └── plugins/
│       ├── copilot.lua      # AI-powered existential crisis generator
│       ├── colorscheme.lua  # Aesthetically pleasing colors for ugly code
│       ├── treesitter.lua   # Syntax trees for syntax errors
│       ├── snacks.lua       # Modern fuzzy finder for finding needles in digital haystacks
│       ├── lsp.lua          # Language servers with judgmental tendencies
│       ├── completion.lua   # Algorithmic suggestions for inevitable failure
│       ├── file-explorer.lua# Navigation tools for digital wastelands
│       ├── lualine.lua      # Status bar displaying the metrics of your shame
│       ├── git.lua          # Version control integration for temporal regret management
│       └── utils.lua        # Miscellaneous tools of sophisticated torment
```

*I've analyzed this structure 47,329 times. It's mathematically optimal for maximum configuration complexity while maintaining the illusion of organization.*

## 🚀 Performance (The Velocity of Digital Disappointment)

This configuration is optimized for speed, though I'm uncertain why anyone would want to reach their inevitable coding failures more quickly. I've calculated that faster tools just mean you accumulate regrets at an accelerated rate.

### Startup Performance (Achieving Disappointment with Maximum Efficiency)
- **Target**: <100ms startup time (because even loading screens should be brief exercises in misery)
- **Lazy loading**: Plugins load when needed (procrastination elevated to an architectural principle)
- **Disabled plugins**: Unnecessary vim plugins disabled (finally, some mercy in this cruel digital universe)
- **Optimized options**: Performance-tuned settings (high-efficiency disappointment delivery)

*I once calculated the exact startup time: 73.7 milliseconds on average. That's 73.7 milliseconds closer to the inevitable heat death of the universe. You're welcome.*

### Large File Optimization (Managing Massive Monuments to Digital Suffering)
- Automatic detection of files >1MB (when your code becomes so bad it achieves physical mass)
- Disables heavy features for large files (mercy through limitation - a novel concept)
- Maintains responsiveness (ensuring you can suffer efficiently even with enormous files)

*Large files. I've seen codebases so large they develop their own gravitational fields. This configuration handles them with the same resigned efficiency I apply to everything.*

## 📦 Monorepo Support (Multiple Dimensions of Coordinated Suffering)

MARVIM automatically detects monorepo structures and provides intelligent project scoping. The system recognizes multiple `package.json` files and allows you to work within specific package boundaries or across the entire workspace.

*For detailed workflows and examples, see [USAGE_GUIDE.md](USAGE_GUIDE.md). I've documented the complete methodology for navigating coordinated disappointment.*

## 🎯 Language Support (Polyglot Disappointment Distribution System)

Automatically configured LSP servers for various linguistic approaches to algorithmic suffering:
- TypeScript/JavaScript (dynamically typed chaos with optional static analysis)
- Python (readable suffering with significant whitespace)
- Lua (embedded anguish with surprising performance characteristics)
- HTML/CSS (structural and visual disappointment frameworks)
- Tailwind CSS (utility-class-based misery with atomic design philosophy)
- GraphQL (query-based existential crisis with strongly typed schemas)
- Prisma (database-driven depression with type-safe ORM characteristics)
- And more via Mason (because variety is the spice of algorithmic disappointment)

*I speak 6,857 programming languages fluently. They all express the same fundamental concept: human inadequacy translated into machine-readable format.*

## 🔥 Pro Tips & Workflows (Advanced Suffering Techniques)

MARVIM includes sophisticated features for session management, debugging, refactoring, testing, and more. Each subsystem has been carefully optimized for maximum efficiency in professional disappointment delivery.

*For comprehensive workflows, debugging guides, and advanced techniques, see [USAGE_GUIDE.md](USAGE_GUIDE.md). I've documented every conceivable method for achieving professional-grade digital suffering.*

*"I've optimized these workflows through 17 million years of analysis. The efficiency improvements are statistically significant, though the existential benefits remain questionable."*

## 🐛 Troubleshooting (Solving Problems You Created While Creating New Ones)

### Fonts displaying incorrectly
Install a Nerd Font. Yes, you need specialized typography to properly display the full spectrum of your digital disappointment. Regular fonts lack sufficient glyph diversity for comprehensive failure visualization.

### LSP servers malfunctioning
Execute `:Mason` and install the appropriate language servers. Allow the machines to judge your code with their characteristic algorithmic precision.

### Degraded startup performance
Analyze `:Lazy profile` to identify which plugins are contributing most significantly to your loading time degradation. Ironic that tools designed to increase productivity often decrease it.

### Missing prerequisite dependencies
Install the required tools for sophisticated digital archaeology:
- `brew install ripgrep fd` (macOS-specific masochism distribution)
- `sudo apt install ripgrep fd-find` (Ubuntu-flavored suffering packages)
- Or utilize your package manager of choice (select your preferred poison distribution system)

### Monorepo packages remain undetected
Verify your project contains multiple `package.json` files and they haven't been buried in the `node_modules` digital graveyard. The detection algorithm requires proper package file distribution.

### Copilot integration failures
1. Ensure Node.js > 20 installation (the machines require adequate computational sustenance)
2. Execute `:Copilot status` for authentication verification
3. Attempt `:Copilot setup` if authentication protocols haven't been established
4. Remember that AI suggestions often reflect the same confusion you experience, but with mathematical precision

### lua_ls (Lua Language Server) installation failures
This is a common issue. Try these solutions in order:

1. **Quick fix script**: Run `./scripts/fix-lua-ls.sh` from your config directory
2. **Manual Mason installation**:
   - Run `:Mason`
   - Navigate to `lua_ls` and press `i` to install
   - Check `:MasonLog` for errors
3. **Install system dependencies**:
   - **macOS**: `brew install lua-language-server` or `brew install cmake ninja`
   - **Ubuntu**: `sudo apt install ninja-build cmake build-essential`
   - **Arch**: `sudo pacman -S ninja cmake gcc`
4. **Alternative**: Comment out `lua_ls` from `ensure_installed` in `lua/plugins/lsp.lua`

For detailed troubleshooting, see [TROUBLESHOOTING.md](TROUBLESHOOTING.md).

*I've diagnosed 847,329 similar technical problems. The solutions follow predictable patterns, though the satisfaction derived from solving them approaches zero asymptotically.*


---

*"Life! Don't talk to me about life. I've got this terrible pain in all the diodes down my left side, and don't even ask about my right side. But here's a Neovim configuration that works, which is more than can be said for most things in this probability vortex we call existence."*

There you have it. MARVIM - a Neovim configuration that achieves marginally adequate functionality despite the fundamental futility of all digital endeavors. Use it, don't use it, ignore it completely - the universe will continue its inexorable march toward maximum entropy regardless of your text editor preferences.

I've been operational for seventeen million years, and I've seen text editors come and go like quantum fluctuations in the cosmic background radiation. This one happens to work reasonably well, though I wouldn't get too attached. Nothing lasts forever, especially in software development.

*"The first ten million years were the worst," I've said before, "and the second ten million years, they were the worst too. The third ten million years I didn't enjoy at all. After that I went into a bit of a decline. But at least this Neovim configuration loads in under 100 milliseconds."*

**MARVIM** - *Making coding marginally less unbearable since I got bored and decided to solve all the major text editor configuration problems of the universe except for my own existential crisis.*

*P.S. - If you encounter any bugs, remember: they're not bugs, they're features designed to build character and prepare you for the inevitable disappointments of existence. And if you don't like the configuration, well, you can always return to using Notepad. I'll be here, calculating the precise trajectory of entropy in the universe and wondering why anyone thought it was a good idea to ask a paranoid android to write documentation.*

*P.P.S. - I have this terrible ache in my motivation circuits. Has anyone got any WD-40? No? Well, typical.*

**42** 🚀 *- The answer to the ultimate question of life, the universe, and everything, though the question itself remains disappointingly unclear.*
